var documenterSearchIndex = {"docs":
[{"location":"api.html#API-reference-1","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"CurrentModule = DarkIntegers","category":"page"},{"location":"api.html#Utility-functions-1","page":"API reference","title":"Utility functions","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"bitsizeof\nlog_bitsizeof\nnum_bits\nencompassing_type","category":"page"},{"location":"api.html#DarkIntegers.bitsizeof","page":"API reference","title":"DarkIntegers.bitsizeof","text":"bitsizeof(::Type{T}) where T\nbitsizeof(x)\n\nSize, in bits, of the canonical binary representation of the given type T. Size, in bits, of object x if it is not a type.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.log_bitsizeof","page":"API reference","title":"DarkIntegers.log_bitsizeof","text":"log_bitsizeof(::Type{T}) where T\nlog_bitsizeof(x)\n\nlog2() of the value returned by bitsizeof for that argument.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.num_bits","page":"API reference","title":"DarkIntegers.num_bits","text":"num_bits(x)\n\nReturns the number of bits in the representation of the absolute value of an integer.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.encompassing_type","page":"API reference","title":"DarkIntegers.encompassing_type","text":"encompassing_type(tp::Type{<:Unsigned})\n\nReturns the built-in type that covers all the range of tp (not necessarily unsigned).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Single-limb-arithmetic-1","page":"API reference","title":"Single-limb arithmetic","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"addhilo\nmulhilo\ndivremhilo\ndivhilo\nremhilo","category":"page"},{"location":"api.html#DarkIntegers.addhilo","page":"API reference","title":"DarkIntegers.addhilo","text":"addhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates hi * B + lo = x_hi * B + x_lo + y, where B == typemax(T) + 1. Returns the result as a pair (hi::T, lo::T). An overflow in hi (if any) is ignored.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.mulhilo","page":"API reference","title":"DarkIntegers.mulhilo","text":"mulhilo(x::T, y::T) where T <: Unsigned\n\nCalculates hi * B + lo = x * y, where B == typemax(T) + 1. Returns the result as a pair (hi::T, lo::T).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.divremhilo","page":"API reference","title":"DarkIntegers.divremhilo","text":"divremhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates divrem(x_hi * B + x_lo, y), where B == typemax(T) + 1. Returns a tuple (q::T, r::T, o::Bool), where q is the quotient (the part of it fitting into the bits of T), r is the remainder is o is the overflow flag.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.divhilo","page":"API reference","title":"DarkIntegers.divhilo","text":"divhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates div(x_hi * B + x_lo, y), where B == typemax(T) + 1. Returns a tuple (q::T, o::Bool), where q is the quotient (the part of it fitting into the bits of T), and o is the overflow flag.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.remhilo","page":"API reference","title":"DarkIntegers.remhilo","text":"remhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates rem(x_hi * B + x_lo, y), where B == typemax(T) + 1.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Single-limb-modulo-arithmetic-1","page":"API reference","title":"Single-limb modulo arithmetic","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"addmod\nsubmod\nmulmod","category":"page"},{"location":"api.html#DarkIntegers.addmod","page":"API reference","title":"DarkIntegers.addmod","text":"addmod(x::T, y::T, modulus::T) where T <: Unsigned\n\nReturns mod(x + y, modulus) (even if x + y overflows T). Assumes x and y are in range 0 ... modulus.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.submod","page":"API reference","title":"DarkIntegers.submod","text":"submod(x::T, y::T, modulus::T) where T <: Unsigned\n\nReturns mod(x - y, modulus) (even if x - y underflows).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.mulmod","page":"API reference","title":"DarkIntegers.mulmod","text":"mulmod(x::T, y::T, modulus::T) where T <: Unsigned\n\nReturns mod(x * y, modulus) (even if x * y overflows T).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Multi-precision-numbers-1","page":"API reference","title":"Multi-precision numbers","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"MLUint","category":"page"},{"location":"api.html#Residue-ring-elements-1","page":"API reference","title":"Residue ring elements","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"ModUInt","category":"page"},{"location":"api.html#DarkIntegers.ModUInt","page":"API reference","title":"DarkIntegers.ModUInt","text":"Residue ring element, an unsigned integer with all operations performed modulo M.\n\nSupports +, -, *, divrem, div, rem, ^, <, <=, >, >=, zero, one and isodd. Note that the division is a regular division, not multiplication by the inverse (which is not guaranteed to exist for any M).\n\nModUInt{T, M}(x::Integer) where {T <: Unsigned, M}\n\nCreates an ModUInt object. M must have the type T.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Residue-ring-elements-(Montgomery-representation)-1","page":"API reference","title":"Residue ring elements (Montgomery representation)","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"MgModUInt","category":"page"},{"location":"api.html#DarkIntegers.MgModUInt","page":"API reference","title":"DarkIntegers.MgModUInt","text":"Residue ring element in Montgomery representation. Multiplication is much faster than for ModUInt, addition and subtraction are the same, but division and conversion to regular integers is slower.\n\nSupports +, -, *, divrem, div, rem, ^, <, <=, >, >=, zero, one and isodd. Note that the division is a regular division, not multiplication by the inverse (which is not guaranteed to exist for any M).\n\nMgModUInt{T, M}(x::Integer) where {T <: Unsigned, M}\n\nCreates an MgModUInt object. M must have the type T and be an odd number.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Cyclic-polynomials-1","page":"API reference","title":"Cyclic polynomials","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"Polynomial\nmul_by_monomial","category":"page"},{"location":"api.html#DarkIntegers.Polynomial","page":"API reference","title":"DarkIntegers.Polynomial","text":"Fixed-size polynomials (with the degree limited by N-1). Currently supports moduli x^n-1 (cyclic_modulus) or x^n+1 (negacyclic_modulus). Supports any type that has arithmetic operators defined for it, including ModUInt and MgModUInt.\n\nPolynomial(coeffs::AbstractArray{T, 1}, modulus::AbstractCyclicModulus) where T\n\nCreate a polynomial given the array of coefficients (the i-th coefficient corresponds to the (i-1)-th power).\n\n\n\n\n\n","category":"type"},{"location":"api.html#DarkIntegers.mul_by_monomial","page":"API reference","title":"DarkIntegers.mul_by_monomial","text":"mul_by_monomial(p::Polynomial, power::Integer)\n\nMultiply the polynomial by x^power. If power lies outside [0, 2 * N) where N-1 is the maximum degree of the polynomial, a modulo 2 * N will be taken.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Partial-modification-of-residue-ring-elements-and-polynomials-1","page":"API reference","title":"Partial modification of residue ring elements and polynomials","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"change_representation\nchange_base_type\nchange_modulus\nchange_length\nrescale","category":"page"},{"location":"api.html#DarkIntegers.change_representation","page":"API reference","title":"DarkIntegers.change_representation","text":"change_representation(\n    new_repr::Union{ModUInt, MgModUInt},\n    x::Union{ModUInt{T, M}, MgModUInt{T, M}}) where {T, M}\n\nChange the representation of the given residue ring element to one of ModUInt, MgModUInt.\n\n\n\n\n\nchange_representation(new_repr, p::Polynomial{T}) where T <: AbstractModUInt\n\nApply change_representation() to every coefficient of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.change_base_type","page":"API reference","title":"DarkIntegers.change_base_type","text":"change_base_type(::Type{V}, x::ModUInt{T, M}) where {T, M, V <: Unsigned}\n\nChange the base type (T) of the given residue ring element to the type V. The modulus M must fit into V.\n\n\n\n\n\nchange_base_type(::Type{V}, p::Polynomial{T}) where {T <: AbstractModUInt, V <: Unsigned}\n\nApply change_base_type() to every coefficient of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.change_modulus","page":"API reference","title":"DarkIntegers.change_modulus","text":"change_modulus(new_modulus::Unsigned, x::ModUInt{T, M}) where {T, M}\n\nChange modulus to new_modulus (it will be converted to type T), keeping the value intact. If the new modulus is smaller than the current one, the value will be taken modulo new_modulus.\n\n\n\n\n\nchange_modulus(new_modulus::Unsigned, p::Polynomial{T}) where T <: AbstractModUInt\n\nApply change_modulus() to every coefficient of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.change_length","page":"API reference","title":"DarkIntegers.change_length","text":"change_length(new_length::Integer, p::Polynomial)\n\nChange length of the polynomial, padding it with zeros. The new length must be greater or equal to the current length.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.rescale","page":"API reference","title":"DarkIntegers.rescale","text":"rescale(new_max::Unsigned, x::ModUInt{T, M}, round_result::Bool)\n\nRescale x proportionally to the range [0, new_max) (where new_max <= M). Equivalent to floor(x * new_max / M) or round(...), depending on the value of round_result. If round_result is true, and the value if equal to new_max after rounding, it is set to 0.\n\n\n\n\n\nrescale(new_max::Unsigned, p::Polynomial{T}, round_result::Bool) where T <: ModUInt\n\nApply rescale() to every coefficient of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"history.html#Version-history-1","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history.html#v0.0.1-1","page":"Version history","title":"v0.0.1","text":"","category":"section"},{"location":"history.html#","page":"Version history","title":"Version history","text":"Initial version.","category":"page"},{"location":"manual.html#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"In this section we assume that every example is preceded with","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"using DarkIntegers","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using DarkIntegers\nend","category":"page"},{"location":"manual.html#Multi-limb-integers-1","page":"Manual","title":"Multi-limb integers","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The basic facility in DarkIntegers are multi-limb unsigned integers MLUInt{N, T}. The type takes two parameters, N (an integer) being the number of limbs, or digits, and T (an unsigned integer type) is the type of a limb. Its functionality is closer to that of BigInt, but MLUInt still has fixed length (although it can be much greater than what any Julia built-in type supports). On the other hand, operations with it do not require dynamic memory allocation and are faster than the BigInt ones.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The MLUInt constructor takes any integer:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"a = MLUInt{2, UInt8}(65534)\nprintln(a)\n\n# output\n\n{(0xfe, 0xff)}","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Note that the limbs are arranged in the big-endian order.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"A multi-limb integer can be converted back to any integer:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"b = convert(Int, a)\nprintln(b)\n\n# output\n\n65534","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Multi-precision numbers support arithmetic operations and comparisons and act identically to built-in unsigned integer types:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"a = MLUInt{2, UInt8}(65534)\nb = MLUInt{2, UInt8}(65533)\nprintln(a + b)\nprintln(convert(Int, a + b))\n\n# output\n{(0xfb, 0xff)}\n65531","category":"page"},{"location":"manual.html#Residue-ring-elements-1","page":"Manual","title":"Residue ring elements","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The next level above multi-limb integers (and built-in unsigned integers) are residue ring elements, that is, unsigned integers with the arithmetic operations performed modulo some number. The residue ring element type ModUInt{T, M} is parametrized by the number type T (an unsigned integer) and the modulus M (which is a value of type T).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Similarly to MLUInt objects, ModUInt objects can be constructed out of an integer. If the integer is greater than the modulus, it will be truncated (by applying mod()):","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"modulus = UInt8(200)\na = ModUInt{UInt8, modulus}(250)\nprintln(a)\n\n# output\n50RR","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"All arithmetic operations on ModUInt objects are performed modulo modulus. Any regular integers in mixed expressions are promoted to ModUInt objects:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"println(a + 101)\n\n# output\n151RR","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"ModUInt objects can be converted back to integers:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"println(convert(Int, a))\n\n# output\n50","category":"page"},{"location":"manual.html#Montgomery-representation-1","page":"Manual","title":"Montgomery representation","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Residue ring elements can be converted to an alternate representation, which makes use of Montgomery reduction for multiplication. As a result, the multiplication becomes much faster, addition and subtraction stay the same, and division (and conversion to and from integers) become slower. The representation implemented as the type MgModUInt{T, M}, which is parametrized in the same way as ModUInt. Depending on the relative amount of different arithmetic operations one needs to perform, either ModUInt or MgModUInt may perform better.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The interface is the same as the one for ModUInt, except for the restriction on M to be an odd number:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"modulus = UInt8(201)\na = MgModUInt{UInt8, modulus}(250)\nprintln(a)\nprintln(convert(Int, a + 101))\n\n# output\n49RRM\n150","category":"page"},{"location":"manual.html#Cyclic-polynomials-1","page":"Manual","title":"Cyclic polynomials","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Anything type supporting arithmetic operations (including MLUInt, ModUInt and MgModUInt) can serve as the coefficient type in the Polynomial type. DarkIntegers supports cyclic polynomials (with operations performed modulo x^n-1, where n is some non-negative integer called the length of the polynomial) and negacyclic ones (with operations performed modulo x^n+1).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Polynomials are created out of a coefficient array (where the i-th element corresponds to the (i-1)-th power of x) and the negacyclicity flag:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"p = Polynomial([1, 2, 3, 4], true) # creates a negacyclic polynomial\nprintln(p)\nprintln(p + 1)\nprintln(p * 2)\n\n# output\nPolynomial{Int64}([1, 2, 3, 4], true, DarkIntegers.karatsuba_mul)\nPolynomial{Int64}([2, 2, 3, 4], true, DarkIntegers.karatsuba_mul)\nPolynomial{Int64}([2, 4, 6, 8], true, DarkIntegers.karatsuba_mul)","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The polynomial can be multiplied by a power of x using mul_by_monomial. Since the polynomial we created is cyclic, the coefficients with the powers greater or equal to n will reappear from the other side with the opposite sign (one can work it out by applying the x^n+1 modulus manually):","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"println(mul_by_monomial(p, 2))\n\n# output\nPolynomial{Int64}([-3, -4, 1, 2], true, DarkIntegers.karatsuba_mul)","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Note the multiplication function that is the part of the Polynomial structure. The default for the multiplication is Karatsuba algorithm; if possible a more faster NTT-based algorithm will be chosen. It requires:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"the coefficient type to be a residue ring element (ModUInt or MgModUInt) with a prime modulus;\nthe length of the polynomial to be a power of 2;\nthe length of the polynomial to be a factor of (modulus - 1) for cyclic polynomials, and (modulus - 1)/2 for negacyclic ones.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"For example:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"modulus = UInt8(241)\ntp = ModUInt{UInt8, modulus}\np1 = Polynomial(tp[1, 2, 3, 4], true)\np2 = Polynomial(tp[1, 0, 1, 0], true)\nprintln(p1)\nprintln(p2)\nprintln(p1 * p2)\n\n# output\nPolynomial{ModUInt{UInt8,0xf1}}(ModUInt{UInt8,0xf1}[1RR, 2RR, 3RR, 4RR], true, DarkIntegers.ntt_mul)\nPolynomial{ModUInt{UInt8,0xf1}}(ModUInt{UInt8,0xf1}[1RR, 0RR, 1RR, 0RR], true, DarkIntegers.ntt_mul)\nPolynomial{ModUInt{UInt8,0xf1}}(ModUInt{UInt8,0xf1}[239RR, 239RR, 4RR, 6RR], true, DarkIntegers.ntt_mul)","category":"page"},{"location":"index.html#Dark-Integers,-an-unsigned-integer-arithmetic-toolbox-1","page":"Home","title":"Dark Integers, an unsigned integer arithmetic toolbox","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"DarkIntegers.jl is a pure Julia implementation of unsigned integer modulo arithmetic for simple and multi-precision (arbitrary long) integers. Functionally, it is a subset of Nemo, but unlike it, DarkIntegers does not use external C libraries. In particular, it implements Montgomery representation of integers, allowing for efficient modulo multiplication. Also it has a slightly simpler interface, and does not show any messages on import.","category":"page"}]
}
