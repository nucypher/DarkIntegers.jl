var documenterSearchIndex = {"docs":
[{"location":"api.html#API-reference-1","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"CurrentModule = DarkIntegers","category":"page"},{"location":"api.html#Utility-functions-1","page":"API reference","title":"Utility functions","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"bitsizeof\nlog_bitsizeof\nnum_bits\nencompassing_type\nas_builtin","category":"page"},{"location":"api.html#DarkIntegers.bitsizeof","page":"API reference","title":"DarkIntegers.bitsizeof","text":"bitsizeof(::Type{T}) where T\nbitsizeof(x)\n\nSize, in bits, of the canonical binary representation of the given type T. Size, in bits, of object x if it is not a type.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.log_bitsizeof","page":"API reference","title":"DarkIntegers.log_bitsizeof","text":"log_bitsizeof(::Type{T}) where T\nlog_bitsizeof(x)\n\nlog2() of the value returned by bitsizeof for that argument.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.num_bits","page":"API reference","title":"DarkIntegers.num_bits","text":"num_bits(x)\n\nReturns the number of bits in the representation of the absolute value of an integer.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.encompassing_type","page":"API reference","title":"DarkIntegers.encompassing_type","text":"encompassing_type(tp::Type{<:Unsigned})\n\nReturns the built-in type that covers all the range of tp (not necessarily unsigned).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.as_builtin","page":"API reference","title":"DarkIntegers.as_builtin","text":"as_builtin(x)\n\nReturns the integer x converted to a builtin type with the minimum suitable size.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Single-limb-arithmetic-1","page":"API reference","title":"Single-limb arithmetic","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"addhilo\nmulhilo\ndivremhilo\ndivhilo\nremhilo","category":"page"},{"location":"api.html#DarkIntegers.addhilo","page":"API reference","title":"DarkIntegers.addhilo","text":"addhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates hi * B + lo = x_hi * B + x_lo + y, where B == typemax(T) + 1. Returns the result as a pair (hi::T, lo::T). An overflow in hi (if any) is ignored.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.mulhilo","page":"API reference","title":"DarkIntegers.mulhilo","text":"mulhilo(x::T, y::T) where T <: Unsigned\n\nCalculates hi * B + lo = x * y, where B == typemax(T) + 1. Returns the result as a pair (hi::T, lo::T).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.divremhilo","page":"API reference","title":"DarkIntegers.divremhilo","text":"divremhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates divrem(x_hi * B + x_lo, y), where B == typemax(T) + 1. Returns a tuple (q::T, r::T, o::Bool), where q is the quotient (the part of it fitting into the bits of T), r is the remainder is o is the overflow flag.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.divhilo","page":"API reference","title":"DarkIntegers.divhilo","text":"divhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates div(x_hi * B + x_lo, y), where B == typemax(T) + 1. Returns a tuple (q::T, o::Bool), where q is the quotient (the part of it fitting into the bits of T), and o is the overflow flag.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.remhilo","page":"API reference","title":"DarkIntegers.remhilo","text":"remhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates rem(x_hi * B + x_lo, y), where B == typemax(T) + 1.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Single-limb-modulo-arithmetic-1","page":"API reference","title":"Single-limb modulo arithmetic","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"addmod\nsubmod\nmulmod\npowmod","category":"page"},{"location":"api.html#DarkIntegers.addmod","page":"API reference","title":"DarkIntegers.addmod","text":"addmod(x::T, y::T, modulus::T) where T <: Unsigned\n\nReturns mod(x + y, modulus) (even if x + y overflows T). Assumes x and y are in range 0 ... modulus.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.submod","page":"API reference","title":"DarkIntegers.submod","text":"submod(x::T, y::T, modulus::T) where T <: Unsigned\n\nReturns mod(x - y, modulus) (even if x - y underflows).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.mulmod","page":"API reference","title":"DarkIntegers.mulmod","text":"mulmod(x::T, y::T, modulus::T) where T <: Unsigned\n\nReturns mod(x * y, modulus) (even if x * y overflows T).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.powmod","page":"API reference","title":"DarkIntegers.powmod","text":"powmod(x::T, y::V, modulus::T) where {T <: Unsigned, V}\n\nReturns mod(x * y, modulus) (even if x * y overflows T).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Multi-precision-numbers-1","page":"API reference","title":"Multi-precision numbers","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"MLUInt\nMLInt","category":"page"},{"location":"api.html#DarkIntegers.MLUInt","page":"API reference","title":"DarkIntegers.MLUInt","text":"Multi-precision unsigned integer type, with N limbs of type T (which must be an unsigned integer type).\n\nSupports +, -, *, divrem, div, rem, mod, ^, ==, !=, <, <=, >, >=, zero, one, oneunit, iseven, isodd, typemin, typemax, iszero, sizeof (can be off if limbs have the type UInt4), bitsizeof, leading_zeros, trailing_zeros, eltype, abs.\n\nAlso supports num_bits, halve, double, encompassing_type.\n\nThe objects can be created either with convert(), or as\n\nMLUInt(x::NTuple{N, T})\nMLUInt{N, T}(x::NTuple{N, V})\n\n\n\n\n\n","category":"type"},{"location":"api.html#DarkIntegers.MLInt","page":"API reference","title":"DarkIntegers.MLInt","text":"Multi-precision unsigned integer type, with N limbs of type T (which must be an unsigned integer type).\n\nSupports +, -, *, divrem, div, rem, mod, ^, ==, !=, <, <=, >, >=, zero, one, oneunit, iseven, isodd, typemin, typemax, iszero, sizeof (can be off if limbs have the type UInt4), bitsizeof, leading_zeros, trailing_zeros, eltype, abs.\n\nAlso supports num_bits, halve, double, encompassing_type.\n\nThe objects can be created either with convert(), or as\n\nMLInt(x::NTuple{N, T})\nMLInt{N, T}(x::NTuple{N, V})\n\n\n\n\n\n","category":"type"},{"location":"api.html#Modulo-integers-1","page":"API reference","title":"Modulo integers","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"ModUInt","category":"page"},{"location":"api.html#DarkIntegers.ModUInt","page":"API reference","title":"DarkIntegers.ModUInt","text":"An unsigned integer with all operations performed modulo M.\n\nSupports +, -, *, divrem, div, rem, ^, <, <=, >, >=, zero, one and isodd. Note that the division is a regular division, not multiplication by the inverse (which is not guaranteed to exist for any M).\n\nModUInt{T, M}(x::Integer) where {T <: Unsigned, M}\n\nCreates an ModUInt object. M must have the type T.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Modulo-integers-(Montgomery-representation)-1","page":"API reference","title":"Modulo integers (Montgomery representation)","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"MgModUInt","category":"page"},{"location":"api.html#DarkIntegers.MgModUInt","page":"API reference","title":"DarkIntegers.MgModUInt","text":"Residue ring element in Montgomery representation. Multiplication is much faster than for ModUInt, addition and subtraction are the same, but division and conversion to regular integers is slower.\n\nSupports +, -, *, divrem, div, rem, ^, <, <=, >, >=, zero, one and isodd. Note that the division is a regular division, not multiplication by the inverse (which is not guaranteed to exist for any M).\n\nMgModUInt{T, M}(x::Integer) where {T <: Unsigned, M}\n\nCreates an MgModUInt object. M must have the type T and be an odd number.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Modulo-integers-helper-functions-1","page":"API reference","title":"Modulo integers helper functions","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"value\nraw_value\nmodulus","category":"page"},{"location":"api.html#DarkIntegers.value","page":"API reference","title":"DarkIntegers.value","text":"raw_value(x::AbstractModUInt{T, M})\n\nReturns the value of type T stored in the object (converted out of any special representation if necessary).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.raw_value","page":"API reference","title":"DarkIntegers.raw_value","text":"raw_value(x::AbstractModUInt{T, M})\n\nReturns the raw value of type T stored in the object (without any conversions).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.modulus","page":"API reference","title":"DarkIntegers.modulus","text":"modulus(::Type{AbstractModUInt{T, M}})\nmodulus(x::AbstractModUInt{T, M})\n\nReturns the modulus M (of type T) for a modulo integer object or type.\n\n\n\n\n\n","category":"function"},{"location":"api.html#(Nega)cyclic-polynomials-1","page":"API reference","title":"(Nega)cyclic polynomials","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"Polynomial\nmul_by_monomial\ncyclic_modulus\nnegacyclic_modulus\nDarkIntegers.known_isprime\nDarkIntegers.known_polynomial_mul_function\nbroadcast_into_polynomial\nbroadcast_into_polynomial!\nwith_modulus\nresize","category":"page"},{"location":"api.html#DarkIntegers.Polynomial","page":"API reference","title":"DarkIntegers.Polynomial","text":"Fixed-size polynomials (with the degree limited by N-1). Currently supports moduli x^n-1 (cyclic_modulus) or x^n+1 (negacyclic_modulus). Supports any type that has arithmetic operators defined for it, including ModUInt and MgModUInt.\n\nPolynomial(coeffs::AbstractArray{T, 1}, modulus::AbstractCyclicModulus) where T\n\nCreate a polynomial given the array of coefficients (the i-th coefficient corresponds to the (i-1)-th power).\n\n\n\n\n\n","category":"type"},{"location":"api.html#DarkIntegers.mul_by_monomial","page":"API reference","title":"DarkIntegers.mul_by_monomial","text":"mul_by_monomial(p::Polynomial, power::Integer)\n\nMultiply the polynomial by x^power. If power lies outside [0, 2 * N) where N-1 is the maximum degree of the polynomial, a modulo 2 * N will be taken.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.cyclic_modulus","page":"API reference","title":"DarkIntegers.cyclic_modulus","text":"A constant denoting cyclic polynomial modulus (x^N - 1), to be supplied to the Polynomial constructor.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#DarkIntegers.negacyclic_modulus","page":"API reference","title":"DarkIntegers.negacyclic_modulus","text":"A constant denoting negacyclic polynomial modulus (x^N + 1), to be supplied to the Polynomial constructor.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#DarkIntegers.known_isprime","page":"API reference","title":"DarkIntegers.known_isprime","text":"known_isprime(::Val{X})\n\nA method of this function can be defined by the user for a certain X to avoid isprime() being called on it when determining the multiplication function for a polynomial (which can reduce start-up time if X is very large).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.known_polynomial_mul_function","page":"API reference","title":"DarkIntegers.known_polynomial_mul_function","text":"known_polynomial_mul_function(::Type{T}, ::Val{N}, polynomial_modulus::AbstractPolynomialModulus)\n\nA method of this function can be defined by the user to specify the multiplication function for a certain polynomial coefficient type, length and modulus. Has to return a function with the signature (p1::Polynomial{T, N}, p2::Polynomial{T, N}) :: Polynomial{T, N}, for example one of DarkIntegers.karatsuba_mul, DarkIntegers.nussbaumer_mul, DarkIntegers.ntt_mul.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.broadcast_into_polynomial","page":"API reference","title":"DarkIntegers.broadcast_into_polynomial","text":"broadcast_into_polynomial(func, args...)\n\nTreat any polynomials in args as 1-dimensional arrays and apply func.(args...), saving the result into a new polynomial.\n\nThe moduli of the polynomials in args must be the same.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.broadcast_into_polynomial!","page":"API reference","title":"DarkIntegers.broadcast_into_polynomial!","text":"broadcast_into_polynomial!(func, p::Polynomial, args...)\n\nTreat p and any polynomials in args as 1-dimensional arrays and apply p .= func.(args...).\n\nThe moduli of the polynomials in args and the modulus of p must be the same.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.with_modulus","page":"API reference","title":"DarkIntegers.with_modulus","text":"with_modulus(p::Polynomial{T, N}, new_modulus::AbstractPolynomialModulus)\n\nReturns a new polynomial object with a changed modulus.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.resize","page":"API reference","title":"DarkIntegers.resize","text":"resize(p::Polynomial, new_length::Integer)\n\nReturns a polynomial with changed length. If new_length is greater than the current length, coefficients for higher powers will be set to 0. If new_length is smaller, coefficients for higher powers will be discarded.\n\n\n\n\n\n","category":"function"},{"location":"api.html#NTT-1","page":"API reference","title":"NTT","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"ntt\nknown_generator","category":"page"},{"location":"api.html#DarkIntegers.ntt","page":"API reference","title":"DarkIntegers.ntt","text":"ntt(data::Array{T, 1}; inverse::Bool=false, tangent::Bool=false) where T <: AbstractModUInt\n\nPerform an NTT on data. If tangent is true, use the tangent NTT (for multiplying tangent polynomials).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.known_generator","page":"API reference","title":"DarkIntegers.known_generator","text":"known_generator(::Val{X})\n\nA method of this function can be defined by the user for a certain X to provide a known generator to use in NTT for this modulus.\n\nA generator is a number g between 0 and X-1 such that g^1 mod X, ..., g^(X-1) mod X are all numbers from 1 to X-1 (in any order).\n\n\n\n\n\n","category":"function"},{"location":"history.html#Version-history-1","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history.html#Current-development-version-1","page":"Version history","title":"Current development version","text":"","category":"section"},{"location":"history.html#","page":"Version history","title":"Version history","text":"FIXED: a typo in convert(::Type{MgModUInt{T, M}}, ::ModUInt{T, M})\nFIXED: known_isprime() is now called even if it is defined in the user program.\nADDED: known_polynomial_mul_function() to override the default choice.","category":"page"},{"location":"history.html#v0.1.1-(20-December-2019)-1","page":"Version history","title":"v0.1.1 (20 December 2019)","text":"","category":"section"},{"location":"history.html#","page":"Version history","title":"Version history","text":"FIXED: a bug in conversion between polynomials of different lengths\nFIXED: added a trivial promote() method to fix some promotion errors","category":"page"},{"location":"history.html#v0.1.0-(19-December-2019)-1","page":"Version history","title":"v0.1.0 (19 December 2019)","text":"","category":"section"},{"location":"history.html#","page":"Version history","title":"Version history","text":"The first semi-stable release.","category":"page"},{"location":"history.html#v0.0.1-1","page":"Version history","title":"v0.0.1","text":"","category":"section"},{"location":"history.html#","page":"Version history","title":"Version history","text":"Initial version.","category":"page"},{"location":"manual.html#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"In this section we assume that every example is preceded with","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"using DarkIntegers","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using DarkIntegers\nend","category":"page"},{"location":"manual.html#Multi-limb-integers-1","page":"Manual","title":"Multi-limb integers","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The basic facility in DarkIntegers are multi-limb unsigned integers MLUInt{N, T}. The type takes two parameters, N (an integer) being the number of limbs, or digits, and T (an unsigned integer type) is the type of a limb. Its functionality is closer to that of BigInt, but MLUInt still has fixed length (although it can be much greater than what any Julia built-in type supports). On the other hand, operations with it do not require dynamic memory allocation and are faster than the BigInt ones.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The MLUInt constructor takes any integer:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"a = MLUInt{2, UInt8}(65534)\nprintln(a)\n\n# output\n\n{(0xfe, 0xff)}","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Note that the limbs are arranged in the big-endian order.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"A multi-limb integer can be converted back to any integer:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"b = convert(Int, a)\nprintln(b)\n\n# output\n\n65534","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Multi-precision numbers support arithmetic operations and comparisons and act identically to built-in unsigned integer types:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"a = MLUInt{2, UInt8}(65534)\nb = MLUInt{2, UInt8}(65533)\nprintln(a + b)\nprintln(convert(Int, a + b))\n\n# output\n{(0xfb, 0xff)}\n65531","category":"page"},{"location":"manual.html#Modulo-integers-1","page":"Manual","title":"Modulo integers","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The next level above multi-limb integers (and built-in unsigned integers) are unsigned integers with arithmetic operations performed modulo some number. The object of type ModUInt{T, M} is parametrized by the number type T (an unsigned integer) and the modulus M (which is a value of type T).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Similarly to MLUInt objects, ModUInt objects can be constructed out of an integer. If the integer is greater than the modulus, it will be truncated (by applying mod()):","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"modulus = UInt8(200)\na = ModUInt{UInt8, modulus}(250)\nprintln(a)\n\n# output\n50RR","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"All arithmetic operations on ModUInt objects are performed modulo modulus. Any regular integers in mixed expressions are promoted to ModUInt objects:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"println(a + 101)\n\n# output\n151RR","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"ModUInt objects can be converted back to integers after extracting its value with value:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"println(convert(Int, value(a)))\n\n# output\n50","category":"page"},{"location":"manual.html#Montgomery-representation-1","page":"Manual","title":"Montgomery representation","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Modulo integers can be converted to an alternate representation, which makes use of Montgomery reduction for multiplication. As a result, the multiplication becomes much faster, addition and subtraction stay the same, and division (and conversion to and from integers) become slower. The representation implemented as the type MgModUInt{T, M}, which is parametrized in the same way as ModUInt. Depending on the relative amount of different arithmetic operations one needs to perform, either ModUInt or MgModUInt may perform better.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The interface is the same as the one for ModUInt, except for the restriction on M to be an odd number:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"modulus = UInt8(201)\na = MgModUInt{UInt8, modulus}(250)\nprintln(a)\nprintln(convert(Int, value(a + 101)))\n\n# output\n49RRM\n150","category":"page"},{"location":"manual.html#Cyclic-polynomials-1","page":"Manual","title":"Cyclic polynomials","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Anything type supporting arithmetic operations (including MLUInt, ModUInt and MgModUInt) can serve as the coefficient type in the Polynomial type. DarkIntegers supports cyclic polynomials (with operations performed modulo x^n-1, where n is some non-negative integer called the length of the polynomial) and negacyclic ones (with operations performed modulo x^n+1).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Polynomials are created out of a coefficient array (where the i-th element corresponds to the (i-1)-th power of x) and negacyclic modulus (x^N+1):","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"p = Polynomial([1, 2, 3, 4], negacyclic_modulus) # creates a negacyclic polynomial\nprintln(p)\nprintln(p + 1)\nprintln(p * 2)\n\n# output\nPolynomial{Int64,4}([1, 2, 3, 4], DarkIntegers.NegacyclicModulus(), DarkIntegers.karatsuba_mul, false)\nPolynomial{Int64,4}([2, 2, 3, 4], DarkIntegers.NegacyclicModulus(), DarkIntegers.karatsuba_mul, false)\nPolynomial{Int64,4}([2, 4, 6, 8], DarkIntegers.NegacyclicModulus(), DarkIntegers.karatsuba_mul, false)","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The polynomial can be multiplied by a power of x using mul_by_monomial. Since the polynomial we created is cyclic, the coefficients with the powers greater or equal to n will reappear from the other side with the opposite sign (one can work it out by applying the x^n+1 modulus manually):","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"println(mul_by_monomial(p, 2))\n\n# output\nPolynomial{Int64,4}([-3, -4, 1, 2], DarkIntegers.NegacyclicModulus(), DarkIntegers.karatsuba_mul, false)","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Note the multiplication function that is the part of the Polynomial structure. The default for the multiplication is Karatsuba algorithm; if possible a more faster NTT-based algorithm will be chosen. It requires:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"the coefficient type to be a modulo integer (ModUInt or MgModUInt) with a prime modulus;\nthe length of the polynomial to be a power of 2;\nthe length of the polynomial to be a factor of (modulus - 1) for cyclic polynomials, and (modulus - 1)/2 for negacyclic ones.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"For example:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"modulus = UInt8(241)\ntp = ModUInt{UInt8, modulus}\np1 = Polynomial(tp[1, 2, 3, 4], negacyclic_modulus)\np2 = Polynomial(tp[1, 0, 1, 0], negacyclic_modulus)\nprintln(p1)\nprintln(p2)\nprintln(p1 * p2)\n\n# output\nPolynomial{ModUInt{UInt8,0xf1},4}(ModUInt{UInt8,0xf1}[1RR, 2RR, 3RR, 4RR], DarkIntegers.NegacyclicModulus(), DarkIntegers.ntt_mul, false)\nPolynomial{ModUInt{UInt8,0xf1},4}(ModUInt{UInt8,0xf1}[1RR, 0RR, 1RR, 0RR], DarkIntegers.NegacyclicModulus(), DarkIntegers.ntt_mul, false)\nPolynomial{ModUInt{UInt8,0xf1},4}(ModUInt{UInt8,0xf1}[239RR, 239RR, 4RR, 6RR], DarkIntegers.NegacyclicModulus(), DarkIntegers.ntt_mul, false)","category":"page"},{"location":"index.html#Dark-Integers,-an-unsigned-integer-arithmetic-toolbox-1","page":"Home","title":"Dark Integers, an unsigned integer arithmetic toolbox","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"DarkIntegers.jl is a pure Julia implementation of unsigned integer modulo arithmetic for simple and multi-precision (arbitrary long) integers. Functionally, it is a subset of Nemo, but unlike it, DarkIntegers does not use external C libraries. In particular, it implements Montgomery representation of integers, allowing for efficient modulo multiplication. Also it has a slightly simpler interface, and does not show any messages on import.","category":"page"}]
}
